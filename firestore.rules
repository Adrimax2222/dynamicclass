
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============= HELPER FUNCTIONS =============
    
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function isGlobalAdmin() {
      // Production admins defined in rules
      let hardcodedAdmins = request.auth != null && request.auth.token.email in [
        'anavarrod@iestorredelpalau.cat',
        'lrotav@iestorredelpalau.cat',
        'adrimax.dev@gmail.com'
      ];
      // Role-based admin from firestore document
      let roleBasedAdmin = request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      
      return hardcodedAdmins || roleBasedAdmin;
    }

    function isCenterAdmin(centerId) {
        let userData = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
        return request.auth != null && 
               (userData.role == 'center-admin' || userData.role == 'admin') &&
               userData.organizationId == centerId;
    }

    function isClassAdmin(className) {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin-' + className;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isValidMessage() {
      return request.resource.data.keys().hasAll(['role', 'content', 'timestamp']) &&
             request.resource.data.role in ['user', 'assistant', 'system'] &&
             request.resource.data.content is string &&
             request.resource.data.content.size() > 0 &&
             request.resource.data.content.size() <= 10000;
    }

    function isValidChat() {
      return request.resource.data.keys().hasAll(['userId', 'title', 'createdAt']) &&
             request.resource.data.userId is string &&
             request.resource.data.title is string &&
             request.resource.data.title.size() > 0 &&
             request.resource.data.title.size() <= 200;
    }

    // ============= USERS COLLECTION =============

    match /users/{userId} {
      allow get: if isOwner(userId) || isGlobalAdmin();
      allow list: if request.auth != null;
      allow create: if request.auth != null; // Allow any authenticated user to create their own profile
      allow delete: if isOwner(userId) || isGlobalAdmin();

      // Allow global admin to update any field, including 'role'
      allow update: if isGlobalAdmin();
      
      // Allow center admin to update roles within their center (but not to 'admin')
      // Also allows them to demote another center admin back to student
      allow update: if isCenterAdmin(resource.data.organizationId) && 
                      request.resource.data.role != 'admin';
      
      // Allow user to assign themselves as center-admin (only during center creation flow)
      allow update: if isOwner(userId) && request.resource.data.role == 'center-admin';

      // Allow user to update their own profile, but not their role or banned status
      allow update: if isOwner(userId) && 
                      request.resource.data.role == resource.data.role &&
                      (!('isBanned' in request.resource.data) || request.resource.data.isBanned == resource.data.isBanned) &&
                      (!('isChatBanned' in request.resource.data) || request.resource.data.isChatBanned == resource.data.isChatBanned);


      // Notes subcollection
      match /notes/{noteId} {
        allow list, get, create, update, delete: if isOwner(userId);
      }
      
      // Events subcollection
      match /events/{eventId} {
        allow list, get, create, update, delete: if isOwner(userId);
      }
      
      // ============= CHATBOT: Chats & Messages =============
      
      // Chats subcollection - MEJORADO
      match /chats/{chatId} {
        // Users can only access their own chats
        allow read: if isOwner(userId);
        
        // Validate chat creation with proper structure
        allow create: if isOwner(userId) && isValidChat() && request.resource.data.userId == userId;
        
        // Allow updates only to specific fields (e.g., title)
        allow update: if isOwner(userId) && 
                      request.resource.data.userId == resource.data.userId && // userId cannot be changed
                      request.resource.data.createdAt == resource.data.createdAt; // createdAt cannot be changed
        
        // Allow deletion
        allow delete: if isOwner(userId);
        
        // Messages subcollection - MEJORADO
        match /messages/{messageId} {
          // Users can only access messages in their own chats
          allow read: if isOwner(userId);
          
          // Strict validation for message creation
          allow create: if isOwner(userId) && isValidMessage();
          
          // Allow update and delete (for editing/removing messages)
          allow update, delete: if isOwner(userId);
        }
      }

      // Completed items history subcollection
      match /completedItems/{itemId} {
        allow list, get, create: if isOwner(userId);
        // No update/delete to keep history immutable
      }
    }
    
    // ============= USER TOKENS =============
    
    match /userTokens/{userId} {
      allow read, write: if isOwner(userId);
    }

    // ============= ANNOUNCEMENTS =============

    match /announcements/{announcementId} {
      // Any authenticated user can read announcements
      allow read: if request.auth != null;

      // Helper function to check if the user is an admin for the announcement's scope
      function canManage(ann) {
        return isGlobalAdmin() ||
               (ann.scope == 'center' && ann.centerId != null && isCenterAdmin(ann.centerId)) ||
               (ann.scope == 'class' && ann.className != null && isClassAdmin(ann.className));
      }

      // CREATE: Allow if the user has the correct admin role for the scope.
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid && canManage(request.resource.data);

      // DELETE: Admins or the original author can delete.
      allow delete: if canManage(resource.data) || isOwner(resource.data.authorId);

      // UPDATE:
      // Admins can update any field.
      allow update: if canManage(resource.data);

      // Authors can ONLY update the text of a text-based announcement.
      allow update: if isOwner(resource.data.authorId) &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text']);

      // Any user can update 'viewedBy' to add themselves.
      allow update: if request.auth != null &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewedBy']) &&
                       request.resource.data.viewedBy.toSet().difference(resource.data.viewedBy.toSet()).hasOnly([request.auth.uid]);

      // Any user can update reactions.
      allow update: if request.auth != null &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);
                       
      // Any user can update poll votes.
      allow update: if request.auth != null &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pollVoteCounts', 'votedUserIds']);
    }

    // ============= CENTERS =============

    match /centers/{centerId} {
      // Allow any authenticated user to create a center, but only admins can update/delete
      allow create: if request.auth != null;
      allow update, delete: if isGlobalAdmin() || isCenterAdmin(centerId);
      allow list, get: if true;
      
        // ============= CLASS CHAT =============
        match /classes/{className}/messages/{messageId} {
            
            function canManageClass() {
                return isGlobalAdmin() || isCenterAdmin(centerId) || isClassAdmin(className);
            }

            function isClassMember() {
                let userData = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
                // Path variable `className` is formatted as "4ESO-B"
                // User data `course` is "4eso" and `className` is "B"
                return userData.organizationId == centerId &&
                       userData.course == className.split('-')[0].lower() &&
                       userData.className == className.split('-')[1];
            }
            
            function canReadChat() {
                return canManageClass() || isClassMember();
            }

            allow read: if canReadChat();
          
            function isValidClassMessage() {
                let message = request.resource.data;
                // Client sends: content, authorId, authorName, authorAvatar, authorRole, timestamp, viewedBy, isPinned
                let expectedKeys = ['content', 'authorId', 'authorName', 'authorAvatar', 'authorRole', 'timestamp', 'viewedBy', 'isPinned'];
                
                return message.keys().hasAll(expectedKeys) &&
                       message.keys().size() == 8 &&
                       message.authorId == request.auth.uid &&
                       message.authorName is string &&
                       message.authorAvatar is string &&
                       message.authorRole is string &&
                       message.content is string && message.content.size() > 0 && message.content.size() <= 2000 &&
                       message.viewedBy == [] &&
                       message.isPinned == false;
            }
            
            allow create: if isClassMember() && isValidClassMessage() && getUserData().isChatBanned != true;
            
            allow delete: if canManageClass() || request.auth.uid == resource.data.authorId;
            
            allow update: if 
              // Rule for editing message content by the author
              (request.resource.data.diff(resource.data).affectedKeys().hasAll(['content', 'editedAt']) && request.auth.uid == resource.data.authorId) ||
              // Rule for pinning/unpinning a message by an admin
              (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isPinned']) && canManageClass()) ||
              // Rule for marking a message as seen by anyone who can read it
              (canReadChat() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewedBy']) && request.resource.data.viewedBy.toSet().difference(resource.data.viewedBy.toSet()).hasOnly([request.auth.uid]));
        }
    }
  }
}
