
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============= HELPER FUNCTIONS =============
    
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function isGlobalAdmin() {
      // Production admins defined in rules
      let hardcodedAdmins = request.auth != null && request.auth.token.email in [
        'anavarrod@iestorredelpalau.cat',
        'lrotav@iestorredelpalau.cat',
        'adrimax.dev@gmail.com',
        'info.dynamicclass@gmail.com'
      ];
      // Role-based admin from firestore document
      let roleBasedAdmin = request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      
      return hardcodedAdmins || roleBasedAdmin;
    }

    function isCenterAdmin(centerId) {
        let userData = get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
        return request.auth != null && 
               (userData.role == 'center-admin' || userData.role == 'admin') &&
               userData.organizationId == centerId;
    }

    function isClassAdmin(className) {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin-' + className;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isValidMessage() {
      return request.resource.data.keys().hasAll(['role', 'content', 'timestamp']) &&
             request.resource.data.role in ['user', 'assistant', 'system'] &&
             request.resource.data.content is string &&
             request.resource.data.content.size() > 0 &&
             request.resource.data.content.size() <= 10000;
    }

    function isValidChat() {
      return request.resource.data.keys().hasAll(['userId', 'title', 'createdAt']) &&
             request.resource.data.userId is string &&
             request.resource.data.title is string &&
             request.resource.data.title.size() > 0 &&
             request.resource.data.title.size() <= 200;
    }

    // ============= USERS COLLECTION =============

    match /users/{userId} {
      allow get: if isOwner(userId) || isGlobalAdmin();
      allow list: if request.auth != null;
      allow create: if request.auth != null; // Allow any authenticated user to create their own profile
      allow delete: if isOwner(userId) || isGlobalAdmin();

      // Allow global admin to update any field, including 'role'
      allow update: if isGlobalAdmin();
      
      // Allow center admin to update roles within their center (but not to 'admin')
      // Also allows them to demote another center admin back to student
      allow update: if isCenterAdmin(resource.data.organizationId) && 
                      request.resource.data.role != 'admin';
      
      // Allow user to assign themselves as center-admin (only when creating/joining a center for the first time)
      allow update: if isOwner(userId) && 
                      request.resource.data.role == 'center-admin' &&
                      (resource.data.center == 'personal' || resource.data.center == 'default');

      // Allow user to update their own profile, but not their role or banned status
      allow update: if isOwner(userId) && 
                      request.resource.data.role == resource.data.role &&
                      (!('isBanned' in request.resource.data) || request.resource.data.isBanned == resource.data.isBanned) &&
                      (!('isChatBanned' in request.resource.data) || request.resource.data.isChatBanned == resource.data.isChatBanned);


      // Notes subcollection
      match /notes/{noteId} {
        allow list, get, create, update, delete: if isOwner(userId);
      }
      
      // Events subcollection
      match /events/{eventId} {
        allow list, get, create, update, delete: if isOwner(userId);
      }

      // Reserved Courses subcollection
      match /reservedCourses/{courseId} {
        allow list, get, create, delete: if isOwner(userId);
      }
      
      // ============= CHATBOT: Chats & Messages =============
      
      // Chats subcollection - MEJORADO
      match /chats/{chatId} {
        // Users can only access their own chats
        allow read: if isOwner(userId);
        
        // Validate chat creation with proper structure
        allow create: if isOwner(userId) && isValidChat() && request.resource.data.userId == userId;
        
        // Allow updates only to specific fields (e.g., title)
        allow update: if isOwner(userId) && 
                      request.resource.data.userId == resource.data.userId && // userId cannot be changed
                      request.resource.data.createdAt == resource.data.createdAt; // createdAt cannot be changed
        
        // Allow deletion
        allow delete: if isOwner(userId);
        
        // Messages subcollection - MEJORADO
        match /messages/{messageId} {
          // Users can only access messages in their own chats
          allow read: if isOwner(userId);
          
          // Strict validation for message creation
          allow create: if isOwner(userId) && isValidMessage();
          
          // Allow update and delete (for editing/removing messages)
          allow update, delete: if isOwner(userId);
        }
      }

      // AI Prompts subcollection for Firestore Extension
      match /chat/{promptId} {
        allow read, create: if isOwner(userId);
        // Only the backend extension should update with a response.
        // Deletion can be allowed for chat history clearing.
        allow update: if false; 
        allow delete: if isOwner(userId);
      }

      // Completed items history subcollection
      match /completedItems/{itemId} {
        allow list, get, create: if isOwner(userId);
        // No update/delete to keep history immutable
      }
    }
    
    // ============= USER TOKENS =============
    
    match /userTokens/{userId} {
      allow read, write: if isOwner(userId);
    }

    // ============= ANNOUNCEMENTS =============

    match /announcements/{announcementId} {
      // Any authenticated user can read announcements
      allow read: if request.auth != null;

      // Helper function to check if the user is an admin for the announcement's scope
      function canManage(ann) {
        return isGlobalAdmin() ||
               (ann.scope == 'center' && ann.centerId != null && isCenterAdmin(ann.centerId)) ||
               (ann.scope == 'class' && ann.className != null && isClassAdmin(ann.className));
      }

      // CREATE: Allow if the user has the correct admin role for the scope.
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid && canManage(request.resource.data);

      // DELETE: Admins or the original author can delete.
      allow delete: if canManage(resource.data) || isOwner(resource.data.authorId);

      // UPDATE:
      // Admins can update any field.
      allow update: if canManage(resource.data);

      // Authors can ONLY update the text of a text-based announcement.
      allow update: if isOwner(resource.data.authorId) &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text']);

      // Any user can update 'viewedBy' to add themselves.
      allow update: if request.auth != null &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewedBy']) &&
                       request.resource.data.viewedBy.toSet().difference(resource.data.viewedBy.toSet()).hasOnly([request.auth.uid]);

      // Any user can update reactions.
      allow update: if request.auth != null &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']);
                       
      // Any user can update poll votes.
      allow update: if request.auth != null &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['pollVoteCounts', 'votedUserIds']);
    }

    // ============= REVIEWS =============
    match /reviews/{reviewId} {
      allow list, get: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if (request.auth != null && resource.data.authorId == request.auth.uid) || isGlobalAdmin();
    }

    // ============= GLOBAL ADMIN FEATURES =============

    match /globalNotes/{noteId} {
      allow read, write: if isGlobalAdmin();
    }

    match /globalChat/{messageId} {
      allow read, write: if isGlobalAdmin();
    }
    
    // ============= COLLECTION GROUP RULES =============
    match /{path=**}/reservedCourses/{courseId} {
        allow get, list: if isGlobalAdmin();
    }
    
    // ============= CENTERS =============

    match /centers/{centerId} {
      // Allow any authenticated user to create a center, but only admins can update/delete
      allow create: if request.auth != null;
      allow update, delete: if isGlobalAdmin() || isCenterAdmin(centerId);
      allow list, get: if true;
      
        // ============= CLASS CHAT (TEMPORARY DEBUG RULES) =============
        match /classes/{className}/messages/{messageId} {
            // WARNING: These are temporary, permissive rules for debugging.
            // They allow any authenticated user to read and write to any class chat.
            // This should be replaced with more secure rules after testing.
            allow read, write: if request.auth != null;
        }
    }
  }
}
