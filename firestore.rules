
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============= HELPER FUNCTIONS =============
    
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function isGlobalAdmin() {
      // Production admins defined in rules
      let hardcodedAdmins = request.auth != null && request.auth.token.email in [
        'anavarrod@iestorredelpalau.cat',
        'lrotav@iestorredelpalau.cat',
        'adrimax.dev@gmail.com'
      ];
      // Role-based admin from firestore document
      let roleBasedAdmin = request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      
      return hardcodedAdmins || roleBasedAdmin;
    }

    function isClassAdmin(className) {
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin-' + className;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isValidMessage() {
      return request.resource.data.keys().hasAll(['role', 'content', 'timestamp']) &&
             request.resource.data.role in ['user', 'assistant', 'system'] &&
             request.resource.data.content is string &&
             request.resource.data.content.size() > 0 &&
             request.resource.data.content.size() <= 10000;
    }

    function isValidChat() {
      return request.resource.data.keys().hasAll(['userId', 'title', 'createdAt']) &&
             request.resource.data.userId is string &&
             request.resource.data.title is string &&
             request.resource.data.title.size() > 0 &&
             request.resource.data.title.size() <= 200;
    }
    
    function isValidAnnouncement() {
      let data = request.resource.data;
      return data.keys().hasAll(['text', 'authorId', 'authorName', 'authorAvatar', 'createdAt', 'scope']) &&
             data.text is string && data.text.size() > 0 && data.text.size() < 1000 &&
             data.scope in ['general', 'center', 'class'];
    }

    // ============= USERS COLLECTION =============

    match /users/{userId} {
      allow get: if isOwner(userId) || isGlobalAdmin();
      allow list: if request.auth != null;
      allow create: if request.auth != null;
      allow delete: if isOwner(userId) || isGlobalAdmin();

      // Allow admin to update any field, including 'role' and 'isBanned'
      allow update: if isGlobalAdmin();
      // Allow user to update their own profile, but not their role or banned status
      allow update: if isOwner(userId) && 
                      request.resource.data.role == resource.data.role &&
                      (!('isBanned' in request.resource.data) || request.resource.data.isBanned == resource.data.isBanned);


      // Notes subcollection
      match /notes/{noteId} {
        allow list, get, create, update, delete: if isOwner(userId);
      }
      
      // Events subcollection
      match /events/{eventId} {
        allow list, get, create, update, delete: if isOwner(userId);
      }
      
      // ============= CHATBOT: Chats & Messages =============
      
      // Chats subcollection - MEJORADO
      match /chats/{chatId} {
        // Users can only access their own chats
        allow read: if isOwner(userId);
        
        // Validate chat creation with proper structure
        allow create: if isOwner(userId) && isValidChat() && request.resource.data.userId == userId;
        
        // Allow updates only to specific fields (e.g., title)
        allow update: if isOwner(userId) && 
                      request.resource.data.userId == resource.data.userId && // userId cannot be changed
                      request.resource.data.createdAt == resource.data.createdAt; // createdAt cannot be changed
        
        // Allow deletion
        allow delete: if isOwner(userId);
        
        // Messages subcollection - MEJORADO
        match /messages/{messageId} {
          // Users can only access messages in their own chats
          allow read: if isOwner(userId);
          
          // Strict validation for message creation
          allow create: if isOwner(userId) && isValidMessage();
          
          // Allow update and delete (for editing/removing messages)
          allow update, delete: if isOwner(userId);
        }
      }

      // Completed items history subcollection
      match /completedItems/{itemId} {
        allow list, get, create: if isOwner(userId);
        // No update/delete to keep history immutable
      }
    }
    
    // ============= USER TOKENS =============
    
    match /userTokens/{userId} {
      allow read, write: if isOwner(userId);
    }

    // ============= ANNOUNCEMENTS =============

    match /announcements/{announcementId} {
      allow list: if request.auth != null;
      allow get: if request.auth != null; // Further filtering on client-side

      // Create: Global admins can create any. Class admins can ONLY create for their class.
      allow create: if isValidAnnouncement() && (isGlobalAdmin() || 
                    (isClassAdmin(request.resource.data.className) && request.resource.data.scope == 'class'));
      
      // Update/Delete: Global admins can manage any. Class admins can ONLY manage their own class announcements.
      allow update, delete: if isGlobalAdmin() || 
                              (isClassAdmin(resource.data.className) && resource.data.scope == 'class');
    }

    // ============= CENTERS =============

    match /centers/{centerId} {
      // Admins can do anything
      allow write: if isGlobalAdmin();
      // Allow ANYONE (authenticated or not) to read the list of centers to validate the code on registration
      allow list, get: if true;
    }
  }
}
